[
  {
    "title": "Welche Aussagen von Clean Code Developer zu Wandelbarkeit in Softwaresystemen treffen zu?",
    "topics": ["Clean Code Developer", "Architektur"],
    "options": [
      "Je länger eine Software besteht, desto teurer sind Änderungen an ihr - grundsätzlich",
      "Wenn die Kosten für Änderungen explodieren, lässt sich dies problemlos in den Griff bekommen",
      "Software die wandelbar ist, lässt sich später kostengünstig anpassen",
      "Wandelbarkeit lässt sich nicht nachträglich erreichen"
    ],
    "correctOptions": [2, 3],
    "source": "https://clean-code-developer.de/das-wertesystem/#Wandelbarkeit"
  },
  {
    "title": "Was sind die wesentlichen Kategorien im Clean Code Developer?",
    "topics": ["Clean Code Developer"],
    "options": [
      "Prinzipien und Praktiken",
      "Wandelbarkeit und Korrektheit",
      "SOLID und DRY",
      "Single Developer und Team"
    ],
    "correctOptions": [0],
    "source": "https://clean-code-developer.de/das-wertesystem/#Prinzipien_und_Praktiken"
  },
  {
    "title": "Clean Code Developer sagt zur Performanceoptimierung von Software ...",
    "topics": ["Clean Code Developer"],
    "options": [
      "Sollte grundsätzlich vor Release erfolgen - der Kunde möchte ja kein langsames Produkt",
      "Performanceoptimierter Code ist schlechter lesbar",
      "Optimierungen räumen viele Probleme aus, bevor sie überhaupt auftreten",
      "Wenn optimieren, dann nur auf Basis von Messungen (z.B. mit einem Profiler)"
    ],
    "correctOptions": [1,3],
    "source": "https://clean-code-developer.de/die-grade/roter-grad/#Beware_of_Premature_Optimization"
  },
  {
    "title": "Wenn eine Variable in Java- oder Type Script mit einem Dollar-Zeichen (`$`) endet, dann bedeutet das ...",
    "topics": ["NgRx", "RxJS", "Frontend"],
    "options": [
      "Dass es sich um eine globale Variable handelt",
      "Dass die Variable `null` oder `undefined` sein kann",
      "Dass die Variable von einem Store gelesen wurde",
      "Dass es sich um ein `Observable` oder `BehaviorSubject` handelt"
    ],
    "correctOptions": [3]
  },
  {
    "title": "Was bedeutet `{{ time$ | async }}` im Markup einer Angular-Komponente?",
    "topics": ["Angular", "Frontend"],
    "options": [
      "Sobald sich `time$` ändert, wird der Wert im Browser aktualisiert",
      "Der Wert der `Observable`-Variable wird einmalig gelesen und ausgegeben",
      "Die Subscription muss beim Zerstören der Komponente manuell im Code-Behind entfernt werden",
      "`time$` darf nur einmalig in der Komponente zugewiesen und auf keinen Fall geändert werden"
    ],
    "correctOptions": [0],
    "source": "https://angular.io/api/common/AsyncPipe"
  },
  {
    "title": "Wie unterscheiden sich Karma und Jasmine?",
    "topics": ["Angular", "Frontend", "Testing"],
    "options": [
      "Gar nicht, beide sind Test-Frameworks",
      "Karma führt Tests aus, Jasmine beschreibt Tests",
      "Jasmine führt Tests aus, Karma beschreibt Tests",
      "Karma wird für React genutzt, Jasmine für Angular"
    ],
    "correctOptions": [1],
    "source": "https://stackoverflow.com/questions/26032124/karma-vs-testing-framework-jasmine-mocha-qunit"
  },
  {
    "title": "Welche Kommandos werden zur Entwicklung einer Angular-App typischerweise genutzt?",
    "topics": ["Angular", "Frontend"],
    "options": [
      "`run` `deploy` `verify`",
      "`start` `pack` `asses`",
      "`serve` `build` `test`",
      "`exec` `bundle` `examine`"
    ],
    "correctOptions": [2],
    "source": "https://angular.io/cli"
  },
  {
    "title": "Ein größeres Feature in eurem Scrum-Team steht an - wie schneidet ihr?",
    "topics": ["Scrum"],
    "options": [
      "Erst die Datenbank, dann das Backend, ganz am Ende das Frontend",
      "Frontend und Backend werden in zwei unterschiedlichen Teams entwickelt",
      "Wir erreichen gemeinsam einen Durchstich in einer Story und fügen mit weiteren Stories mehr Funktionen hinzu"
    ],
    "correctOptions": [2],
    "source": "https://agileforall.com/wp-content/uploads/2020/12/Story-Splitting-Flowchart.pdf"
  },
  {
    "title": "Welche der folgenden Rollen sind offiziell Teil des Scrum-Teams?",
    "topics": ["Scrum"],
    "options": [
      "Developer",
      "Business Analyst",
      "Product Owner",
      "Scrum Master",
      "Stakeholder",
      "Project Manager"
    ],
    "correctOptions": [0,2,3],
    "source": "https://scrumguides.org/scrum-guide.html#scrum-team"
  },
  {
    "title": "Auf was committen sich die Entwickler eines Scrum-Teams?",
    "topics": ["Scrum"],
    "options": [
      "Die Produktvision",
      "Die Roadmap",
      "Die Stories im Sprint",
      "Das Sprint-Ziel",
      "Die Definition of Read (DoR)",
      "Die Definition of Done (DoD)"
    ],
    "correctOptions": [0,3,5],
    "source": "https://scrumguides.org/scrum-guide.html#scrum-artifacts"
  },
  {
    "title": "Darf ein Sprint abgebrochen werden, wenn das Ziel nicht mehr zweckmäßig ist?",
    "topics": ["Scrum"],
    "options": [
      "Ja, da in dem Fall kein sinnvolles Increment geliefert werden kann",
      "Nein, die Kadenz muss gewahrt bleiben da sonst zuviel Chaos verursacht wird"
    ],
    "correctOptions": [0],
    "source": "https://scrumguides.org/scrum-guide.html#the-sprint"
  },
  {
    "title": "Soll Scrum den Bedarf an anderen Meetings verringern?",
    "topics": ["Scrum"],
    "options": [
      "Ja",
      "Nein"
    ],
    "correctOptions": [0],
    "source": "https://scrumguides.org/scrum-guide.html#scrum-events"
  },
  {
    "title": "Welche Aussagen zum Review in Scrum treffen zu?",
    "topics": ["Scrum"],
    "options": [
      "Es handelt sich um ein Präsentationsmeeting, Fragen sollten immer ausgelagert werden",
      "Das Review ist ein Arbeitsmeeting, bei dem das Team die Inkremente vorstellt und Feedback für die weitere Entwicklung einholt",
      "Entwickler zeigen, was sie entwickelt haben, ein 'zu technisch' gibt es nicht",
      "Das Review bedarf keiner Vorbereitung durch das Team"
    ],
    "correctOptions": [1],
    "source": "https://scrumguides.org/scrum-guide.html#sprint-review"
  },
  {
    "title": "Welche Aussagen zur Retrospektive in Scrum treffen zu?",
    "topics": ["Scrum"],
    "options": [
      "Das Meeting sollte nicht länger als eine Stunde dauern",
      "Die Retro sollte einer sichere Umgebung sein, in der Misstände offen angesprochen werden können",
      "Wenn Manager an der Retro teilnehmen möchten, können sie dies gerne jederzeit tun",
      "Für die wichtigsten Punkte werden Aktionen abgeleitet, die so früh wie möglich angegangen werden"
    ],
    "correctOptions": [1,3],
    "source": "https://scrumguides.org/scrum-guide.html#sprint-retrospective"
  },
  {
    "title": "Im Planning soll der nächste Sprint befüllt werden. Was stimmt?",
    "topics": ["Scrum"],
    "options": [
      "Der Product Owner selektiert die Stories vor, die bearbeitet werden sollen",
      "Die Roadmap entscheidet den Inhalt des Sprints",
      "Der Product Owner stellt vor, welchen Mehrwert er gerne mit dem nächsten Sprint erreichen möchte",
      "Die Entwickler wählen die Stories, die im Sprint bearbeitet werden sollen"
    ],
    "correctOptions": [2,3],
    "source": "https://scrumguides.org/scrum-guide.html#sprint-planning"
  },
  {
    "title": "Was ist der Nutzen von asynchroner Programmierung im Backend?",
    "topics": ["Backend", "Architektur"],
    "options": [
      "Es können mehr Requests parallel ausgeführt werden",
      "Einzelne Requests werden beschleunigt ausgeführt",
      "Requests, die auf Ressourcen warten, können andere nicht mehr blockieren",
      "Funktionen sind einfacher zu entwickeln"
    ],
    "correctOptions": [0,2]
  },
  {
    "title": "Welche Ziele verfolgt Clean Architecture?",
    "topics": ["Architektur"],
    "options": [
      "Unabhängigkeit der Business-Logik von UI, Datenbanktechnologie und Frameworks im Allgemeinen",
      "Verbesserte Testbarkeit durch Isolierung der Business-Logik",
      "Verbesserte Planbarkeit durch inkrementelle Entwicklung",
      "Eine saubere Domäne durch lose Koppelung der Business-Logik"
    ],
    "correctOptions": [0,1],
    "source": "https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html"
  },
  {
    "title": "Was ist das wesentliche Element von Clean Architecture?",
    "topics": ["Architektur"],
    "options": [
      "Ein Sechseck mit verschiedenen Schichten, wobei die innere Schicht nichts von den äußeren weiß",
      "Ein Kreisdiagramm, bei dem der Output des letzten Schritts wieder in den ersten mündet",
      "Ein Kreis mit verschiedenen Schichten, wobei die innere Schicht nichts von den äußeren weiß",
      "Eine Pyramide, die nach oben hin immer fachlicher wird"
    ],
    "correctOptions": [2],
    "source": "https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html"
  },
  {
    "title": "Wie unterscheidet sich Clean Architecture vom Onion-Modell?",
    "topics": ["Architektur"],
    "options": [
      "Das Onion-Modell trennt zwischen Application- und Domain-Services, bei Clean Architecture wird lediglich abstrakt zwischen Use-Cases und Entities getrennt",
      "Clean Architecture ist der Vorgänger des Onion-Modells",
      "Das Onion-Modell sieht die Datenbank als zentrales Element in der Mitte, Clean Architecture abstrahiert diese Abhängigkeit",
      "Clean Architecture ist ein Meta-Model, welches durch das Onion-Modell implementiert werden könnte"
    ],
    "correctOptions": [0,3],
    "source": "https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html"
  },
  {
    "title": "Was besagt die Dependency Rule in Clean Architecture?",
    "topics": ["Architektur"],
    "options": [
      "Ein Element der äußeren Schichten darf keinen Einfluss auf ein Element der inneren Schichten haben",
      "Die Interaktion mit äußeren Schichten erfolgt immer über Kontrakte / Interfaces",
      "Anwendungen sollten stets einen Dependency Injection Container verwenden",
      "Das Erzeugen von Events beim Ändern von Entities ist verboten"
    ],
    "correctOptions": [0,1],
    "source": "https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html"
  },
  {
    "title": "Wie werden Daten in Kafka persistiert?",
    "topics": ["Kafka"],
    "options": [
      "In einer relationalen Datenbank, beispielsweise Postgres",
      "In spezialisierten Systemen wie Apache Hadoop",
      "In S3-Buckets die per Konfiguration angegeben werden",
      "In einer fortlaufend geschriebenen Log-Datei"
    ],
    "correctOptions": [3],
    "source": "https://docs.confluent.io/kafka/design/file-system-constant-time.html"
  },
  {
    "title": "In welchem Format speichert Kafka Daten?",
    "topics": ["Kafka"],
    "options": [
      "Binär",
      "JSON",
      "Avro",
      "Protobuf",
      "XML",
      "gRPC"
    ],
    "correctOptions": [0],
    "source": "https://developer.confluent.io/courses/architecture/get-started/"
  },
  {
    "title": "Wieso ist Kafka so schnell?",
    "topics": ["Kafka"],
    "options": [
      "Kafka setzt konsequent auf asynchrone Entwicklung",
      "Das Lesen von Events entspricht einem sequentiellen Lesen der Log-Datei",
      "Kritische Sektionen sind in Assembler entwickelt"
    ],
    "correctOptions": [1],
    "source": "https://docs.confluent.io/kafka/design/file-system-constant-time.html"
  },
  {
    "title": "Welche Rolle spielen Broker in Kafka?",
    "topics": ["Kafka"],
    "options": [
      "Sie koordinieren die Zugriffe auf die zentrale Datenbank",
      "Sie merken sich die Position der Konsumenten in den Logs",
      "Sie speichern die Schemata der in den Topics gespeicherten Daten",
      "Sie replizieren die Topics untereinander und erlauben Konsumenten den Zugriff"
    ],
    "correctOptions": [1,3],
    "source": "https://developer.confluent.io/courses/architecture/broker/"
  },
  {
    "title": "Wie können unterschiedliche Konsumenten von Kafka-Events jeweils die selben Nachrichten eines Topics erhalten, ohne dass sie sich gegenseitig beeinflussen?",
    "topics": ["Kafka"],
    "options": [
      "Durch Duplikation des Topics mit Hilfe von Kafka Streams",
      "Die Konsumenten merken sich selbst die letzte Nachricht, die sie selbst gelesen haben",
      "Durch die Verwendung von Consumer Groups"
    ],
    "correctOptions": [2],
    "source": "https://developer.confluent.io/courses/architecture/consumer-group-protocol/"
  },
  {
    "title": "Wie wird Asynchronität von REST-Endpunkten in Quarkus erreicht?",
    "topics": ["Quarkus"],
    "options": [
      "Durch Verwendung von Mutiny",
      "Durch Verwendung von Kotlin Co-Routines",
      "Durch Verwendung von Websockets",
      "Durch Verwendung von Reactive Entities mit Panache"
    ],
    "correctOptions": [0,1,3],
    "source": "https://quarkus.io/guides/getting-started-reactive#from-sequential-to-continuation-style"
  },
  {
    "title": "Welche Elemente sind Teil von SOLID?",
    "topics": ["Architektur", "Clean Code Developer"],
    "options": [
      "Speration of Concerns (SoC)",
      "Single Responsibility Principle (SRP)",
      "Open Closed Principle (OCP)",
      "Object Oriented Programming (OOP)",
      "Liskov Substitution Principle (LSP)",
      "Law of Demeter (LoD)",
      "Interface Segregation Principle (ISP)",
      "Information Hiding Priciple (IHP)",
      "Don't Repeat Yourself (DRY)",
      "Dependency Inversion Principle (DIP)"
    ],
    "correctOptions": [1, 2, 4, 6, 9],
    "source": "https://clean-code-developer.de/weitere-infos/solid/"
  },
  {
    "title": "Welche Aussagen zu Seperation of Concerns (SoC) treffen zu?",
    "topics": ["Architektur", "Clean Code Developer"],
    "options": [
      "SoC verbessert die Testbarkeit",
      "Eine Klasse darf nur genau einen Concern haben",
      "Concerns sollten innerhalb einer Klasse gruppiert und gekennzeichnet werden",
      "SoC führt zu loser Kopplung und hoher Kohäsion"
    ],
    "correctOptions": [0, 2, 3],
    "source": "https://clean-code-developer.de/die-grade/orangener-grad/#Separation_of_Concerns_SoC"
  },
  {
    "title": "Welche Aussagen zum Single Responsibility Principle (SRP) treffen zu?",
    "topics": ["Architektur", "Clean Code Developer"],
    "options": [
      "Zusammengehörige Business-Logik sollt immer in einer einzigen Klasse implementiert werden",
      "Je mehr Klassen geändert werden müssen, desto höher das Risiko für Probleme",
      "Eine Klasse sollte nur eine Verantwortlichkeit haben",
      "Eine Teildomäne in DDD sollte immer aus einer einzigen Entity bestehen"
    ],
    "correctOptions": [1, 2],
    "source": "https://clean-code-developer.de/die-grade/orangener-grad/#Single_Responsibility_Principle_SRP"
  },
  {
    "title": "Welche Aussagen zum Open Closed Principle (OCP) treffen zu?",
    "topics": ["Architektur", "Clean Code Developer"],
    "options": [
      "Vaterklassen sollten offen (open) implementiert werden, abgeleitete Klassen geschützt (closed) werden",
      "Eine Klasse sollte offen für Modifikationen, aber geschlossen für Erweiterungen sein",
      "Der Einsatz des Strategy Patterns kann das OCP unterstützen",
      "Eine Klasse sollte offen für Erweiterungen, aber geschlossen für Modifikationen sein"
    ],
    "correctOptions": [2, 3],
    "source": "https://clean-code-developer.de/die-grade/gruener-grad/#Open_Closed_Principle"
  },
  {
    "title": "Welche Aussagen zum Liskov Substitution Principle (LSP) treffen zu?",
    "topics": ["Architektur", "Clean Code Developer"],
    "options": [
      "Eine Kindklasse sollte keine Exception werfen, wenn die Vaterklasse dies nicht tut",
      "Eine Kindklasse darf die Funktion der Vaterklasse erweitern, aber nicht einschränken",
      "Es sollten nie mehr als zwei Vererbungsstufen verwendet werden",
      "Eine Kindklasse darf die Funktion der Vaterklasse einschränken, aber nicht erweitern"
    ],
    "correctOptions": [0, 1],
    "source": "https://clean-code-developer.de/die-grade/gelber-grad/#Liskov_Substitution_Principle"
  },
  {
    "title": "Welche Aussagen zum Law of Demeter (LoD) treffen zu?",
    "topics": ["Architektur", "Clean Code Developer"],
    "options": [
      "Ein Zugriff auf `meinePrivateMethode().einGetter.methode()` ist okay",
      "Ein Zugriff auf `einParameter.methode()` ist okay",
      "Ein Zugriff auf `einParameter.einGetter.methode()` ist okay",
      "Ein Zugriff auf `meinePrivateMethode()` ist okay"
    ],
    "correctOptions": [1, 3],
    "source": "https://clean-code-developer.de/die-grade/gruener-grad/#Law_of_Demeter_LoD"
  },
  {
    "title": "Welche Aussagen zum Interface Segregation Principle (ISP) treffen zu?",
    "topics": ["Architektur", "Clean Code Developer"],
    "options": [
      "Ein Interface sollte immer nur einen einzigen Concern ausdrücken",
      "Ein Interface sollte keine Details von möglichen Implementierungen enthalten",
      "Ein Interface sollte nicht von anderen Interfaces abhängen",
      "Ein Interface sollte so wenig wie nötig Definitionen enthalten"
    ],
    "correctOptions": [1, 3],
    "source": "https://clean-code-developer.de/die-grade/gelber-grad/#Interface_Segregation_Principle_ISP"
  },
  {
    "title": "Welche Aussagen zum Information Hiding Priciple (IHP) treffen zu?",
    "topics": ["Architektur", "Clean Code Developer"],
    "options": [
      "Je mehr Informationen eine Schnittstelle preisgibt, desto besser für das UI",
      "Jede Schnittstelle sollte nur nötige Informationen nach außen geben",
      "Nach außen freigegebene Informationen lassen sich später problemlos ändern"
    ],
    "correctOptions": [1],
    "source": "https://clean-code-developer.de/die-grade/gelber-grad/#Information_Hiding_Principle"
  },
  {
    "title": "Welche Aussagen zu Don't Repeat Yourself (DRY) treffen zu?",
    "topics": ["Architektur", "Clean Code Developer"],
    "options": [
      "Copy & Paste von Code entspricht dem agilen Geist",
      "Es ist häufig besser, Code zu duplizieren als weitere, abstrakte Strukturelemente hinzuzufügen",
      "Refactorings können helfen, duplizierte Code-Stellen zu reduzieren",
      "Code-Duplizierung sorgt für unwartbare Software"
    ],
    "correctOptions": [2, 3],
    "source": "https://clean-code-developer.de/die-grade/roter-grad/#Dont_Repeat_Yourself_DRY"
  },
  {
    "title": "Welche Aussagen zum Dependency Inversion Principle (DIP) treffen zu?",
    "topics": ["Architektur", "Clean Code Developer"],
    "options": [
      "Verwendet eine High-Level Klasse eine Low-Level Klasse unmittelbar, so ist diese schwerer zu testen",
      "Das Injizieren von Abhängigkeiten per Konstruktor ist immer schlecht",
      "High- und Low-Level-Klassen sollten optimalerweise über Interfaces entkoppelt sein",
      "Abhängigkeiten sollten im besten Fall schon zur Compile-Zeit bekannt sein"
    ],
    "correctOptions": [0, 2],
    "source": "https://clean-code-developer.de/die-grade/gelber-grad/#Dependency_Inversion_Principle"
  }
]
